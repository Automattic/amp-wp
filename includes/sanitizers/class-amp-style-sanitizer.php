<?php

require_once( AMP__DIR__ . '/includes/sanitizers/class-amp-base-sanitizer.php' );
require_once( AMP__DIR__ . '/includes/sanitizers/class-amp-allowed-styles-generated.php' );

/**
 * Collects inline styles and outputs them in the amp-custom stylesheet.
 */
class AMP_Style_Sanitizer extends AMP_Base_Sanitizer {

	/**
	 * The array generated from the AMP spec related to CSS styles. This array
	 * comes from the $allowed_styles array in the AMP_Allowed_Styles_Generated
	 * class that is generated by the amp_wp_build_styles.py script.
	 * @var array
	 */
	private $allowed_custom_styles;

	/**
	 * Holds a list of sanitized CSS declarations
	 * @var array
	 */
	private $styles = array();


	public function __construct( $dom, $args = array() ) {
		parent::__construct( $dom, $args );

		// Load the allowed styles from the generated AMP_Allowed_Styles_Generated class.
		$this->allowed_custom_styles = apply_filters( 'amp_allowed_custom_styles', AMP_Allowed_Styles_Generated::get_custom_styles_for_amp_html() );
	}

	/**
	 * Allows an external function to request the array of sanitized CSS declarations.
	 * 
	 * @return array The list of sanitized CSS declarations.
	 */
	public function get_styles() {
		return $this->styles;
	}

	/**
	 * This starts the sanitizer running against the body of the DOM specified
	 * in the constructor.
	 */
	public function sanitize() {
		$body = $this->get_body_node();
		$this->collect_styles_recursive( $body );
	}

	/**
	 * Recursively loops over each node in the body of the DOM and collects all inline styles
	 * which are removed from the body node, sanitized, and added to the $styles
	 * array.
	 * 
	 * @param  DOMElement $node The root node to start parsing from (should be <body>).
	 */
	private function collect_styles_recursive( $node ) {
		if ( $node->nodeType !== XML_ELEMENT_NODE ) {
			return;
		}

		if ( $node->hasAttributes() && $node instanceof DOMElement ) {
			$style = $node->getAttribute( 'style' );
			$class = $node->getAttribute( 'class' );

			if ( $style ) {
				$style = $this->process_style( $style );
				if ( ! empty( $style ) ) {
					$class_name = $this->generate_class_name( $style );
					$new_class  = trim( $class . ' ' . $class_name );
					$node->setAttribute( 'class', $new_class );
					$this->styles[ '.' . $class_name ] = $style;
				}

				$node->removeAttribute( 'style' );
			}
		}

		$length = $node->childNodes->length;
		for ( $i = $length - 1; $i >= 0; $i -- ) {
			$child_node = $node->childNodes->item( $i );
			$this->collect_styles_recursive( $child_node );
		}
	}

	/**
	 * Given a CSS declaration block (without curly braces), this function will
	 * break the block down into individual declarations and sanitize each one, 
	 * returning an array of sanitized CSS declarations.
	 * 
	 * The following explanation is meant to help clarify the terms used in this
	 * function: A CSS rule-set consists of a selector and a declaration block. 
	 * Each declaration block contains one or more declarations separated by a
	 * semicolon (;). A declaration block always ends with a semicolon. A 
	 * declaration consists of a property and a value, separated by a colon (:).
	 *
	 * See: https://www.w3.org/TR/css-syntax-3/#qualified-rule
 	 *
 	 *                      CSS rule-set
 	 * vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
 	 *   selector                declaration block
 	 * vvvvvvvvvvv vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
 	 *                       declaration         declaration 
	 *               vvvvvvvvvvvvvvvvvvvvvvvvv vvvvvvvvvvvvvvv
	 * .class-name { background-color:#0b0b0b; font-size:16px; }
	 *               ^^^^^^^^^^^^^^^^ ^^^^^^^
	 *                   property      value
	 * 
	 * @param  string $declaration_block A CSS declaration block (see above)
	 * @return string                    A sanitized CSS declaration block.
	 */
	private function process_style( $declaration_block ) {

		if ( empty( $declaration_block ) ) {
			return array();
		}

		// Split the declaration block into individual declarations.
		$declarations = self::css_explode( $declaration_block );

		// Sort declarations
		sort( $declarations );

		/**
		 * Trim whitespace, ensure that each declaration has exactly two 
		 * parts (a property and a value), and filter each declaration
		 * using rules from the AMP specification.
		 */
		$processed_declarations = array();
		foreach ( $declarations as $declaration ) {
			// Split a declaration into a property and a value and trim whitespace.
			$args = array( 'separator' => ':' );
			$declaration_parts = self::css_explode( $declaration, $args );

			// If there are not exactly two parts to this declaration, stop
			// stop processing and ignore this declaration.
			if ( 2 !== count( $declaration_parts ) ) {
				continue;
			}
			$declaration = $declaration_parts[0] . ':' . $declaration_parts[1];

			// Sanitize this declaration and stop processing and ignore this 
			// declaration if sanitization returns an empty string.
			$declaration = $this->sanitize_amp_custom_style( $declaration );
			if ( empty( $declaration ) ) {
				continue;
			}

			$processed_declarations[] = $declaration;
		}

		return $processed_declarations;
	}

	/**
	 * Given a CSS declaration or declaration block, break the string into an 
	 * array of substrings using the separator specified in the args.
	 *
	 * This function works similarly to the php explode() function, but it will
	 * ignore separators that are inside a quoted string or inside brackets.
	 *
	 * Consider the following CSS declaration block:
	 *
	 * height:44px;background:url(data:image/png;base64,iVBORw0K...SuQmCC);
	 *
	 * To split this block into individual declarations, we want to split on
	 * the semicolon between '..44px' and 'background...', but not on the semicolon
	 * between '...png' and 'base64...'. This function will ignore the second
	 * semicolon because it is inside the parentheses in the 'url(...)' value.
	 *
	 * Similarly, when splitting a declaration into a property and a value, it is
	 * possible to specify a colon as the separator in the $args and the 'background'
	 * declaration in the example above would be split into:
	 * 
	 * array (
	 * 		0 => string 'background',
	 * 		1 => string 'url(data:image/png;base64,iVBORw0K...SuQmCC)',
	 * )
	 *
	 * The colon between '...data' and 'image...' would be ignored because it is
	 * inside the parentheses.
	 * 
	 * @param  string $str  The string to parse.
	 * @param  array  $args Overrides for the default arguments.
	 * @return array        An array of substrings.
	 */
	public static function css_explode( $str, $args = array() ) {

		$defaults = array(
			'separator' => ';',
			'left_bracket' => '(',
			'right_bracket' => ')',
			'quote_1' => '\'',
			'quote_2' => '"',
			'ignore_escaped_quotes' => true,
			'trim_whitespace' => true,
		);

		$args = wp_parse_args( $args, $defaults );

		$char = null;
	    $buffer = '';
	    $stack = array();
	    $bracket_depth = 0;
	    $in_quotes_1 = false;
	    $in_quotes_2 = false;
	    
	    $len = strlen( $str );
	    for ( $i=0; $i < $len ; $i++ ) {

			$previouschar = $char;
			$char = $str[ $i ];

			switch ( $char ) {

				case $args['separator']:
					if ( ( ! $in_quotes_1 ) && ( ! $in_quotes_2 ) && ( 0 === $bracket_depth ) ) {
						if ( '' !== $buffer ) {
							if ( $args['trim_whitespace'] ) {
								$buffer = trim( $buffer );
							}
							$stack[] = $buffer;
							$buffer = '';
						}
						continue 2;
					}
					break;

				case $args['quote_1']:
				    if ( 0 === $bracket_depth ) {
						if ( $args['ignore_escaped_quotes'] ) {
							if ( '\\' !== $previouschar  ) {
								$in_quotes_1 = !$in_quotes_1;
							}
						} else {
							$in_quotes_1 = !$in_quotes_1;
						}

						if ( ! $in_quotes_1 ) {
							$in_quotes_2 = false;
						}
				    }
					break;

				case $args['quote_2']:
				    if ( 0 === $bracket_depth ) {
						if ( $args['ignore_escaped_quotes'] ) {
							if ( '\\' !== $previouschar ) {
								$in_quotes_2 = !$in_quotes_2;
							}
						} else {
							$in_quotes_2 = !$in_quotes_2;
						}

						if ( ! $in_quotes_2 ) {
							$in_quotes_1 = false;
						}
				    }
					break;

				case $args['left_bracket']:
					if ( ( ! $in_quotes_1 ) && ( ! $in_quotes_2 ) ) {
						$bracket_depth++;
					}
					break;

				case $args['right_bracket']:
					if ( ( ! $in_quotes_1 ) && ( ! $in_quotes_2 ) ) {
						if ( $bracket_depth ) {
							$bracket_depth--;
						} else {
							$stack[] = $buffer . $char;
							$buffer = '';
							continue 2;
						}
					}
					break;
			}

	        $buffer .= $char;
	    }

		if ( '' !== $buffer ) {
			if ( $args['trim_whitespace'] ) {
				$buffer = trim( $buffer );
			}
			$stack[] = $buffer;
		}

		return $stack;
	}

	/**
	 * Given a css declaration, use the AMP specification to remove any disallowed
	 * data.
	 *
	 * The AMP specification currently includes the following rules that might
	 * apply to custom styles:
	 *
	 * - Image URL spec (https://github.com/ampproject/amphtml/blob/master/validator/validator-main.protoascii#L574)
	 * - CData spec (https://github.com/ampproject/amphtml/blob/master/validator/validator-main.protoascii#L590)
	 *
	 * If more rules are defined in the AMP spec, they should be checked here.
	 * 
	 * @param  string $styles The CSS declaration to sanitize
	 * @return string         A sanitized CSS declaration (may be empty).
	 */
	private function sanitize_amp_custom_style( $style ) {

		// Sanitize image URL, if one exists.
		if ( isset( $this->allowed_custom_styles['cdata_spec_list']['css_spec']['image_url_spec'] ) ) {
			$style = $this->sanitize_url( $style, $this->allowed_custom_styles['cdata_spec_list']['css_spec']['image_url_spec'] );
		}

		// Sanitize any disallowed cdata in this declaration.
		if ( isset( $this->allowed_custom_styles['cdata_spec_list'] ) ) {
			$style = $this->sanitize_cdata( $style, $this->allowed_custom_styles['cdata_spec_list'] );
		}

		return $style;
	}

	/**
	 * Sanitize a URL in a CSS declaration based on the provided url_spec.
	 *
	 * The url_spec should come from an 'image_url_spec' array from the
	 * $allowed_styles array in the AMP_Allowed_Styles_Generated class
	 * that is generated by the amp_wp_build_styles.py python script.
	 *
	 * Following is an example `image_url_spec`:
	 *
	 * 'image_url_spec' => array(
	 * 		'allow_empty' => true,
	 * 		'allow_relative' => true,
	 * 		'allowed_protocol' => array(
	 * 			'absolute',
	 * 			'data',
	 * 			'http',
	 * 			'https',
	 * 		),
	 * 	),
	 * 
	 * @param  string $styles   CSS declaration to sanitize.
	 * @param  string $url_spec The AMP url_spec to use when processing.
	 * @return string           The sanitized CSS declaration (may be empty).
	 */
	private function sanitize_url( $styles, $url_spec ) {
		// Does this style declaration include a URL?
		if ( false !== strpos( $styles, 'url(' ) ) {

			// Break the declaration into parts to isolate the URL.
			$matched = preg_match( '/(.*)url\\(\\s*[\'"]?(.*?)?[\'"]?\\s*\\)(.*)/u', $styles, $matches );
			
			// If we coldn't isolate the URL, stop processing and return an empty string.
			if ( ( 1 !== $matched ) || ( 4 !== count( $matches ) ) ) {
				return '';
			}

			$before_url = $matches[1];
			$url = $matches[2];
			$after_url = $matches[3];

			$parsed_url = parse_url( $url );

			// If the URL has a disallowed protocol, remove the URL.
			if ( isset( $parsed_url['scheme'] ) && is_array( $url_spec['allowed_protocol'] ) &&
				( ! in_array( $parsed_url['scheme'], $url_spec['allowed_protocol'] ) ) ) {
				$url = '';
			}

			// If the protocol empty and a relative URL is disallowed, remove the URL.
			if ( empty( $parsed_url['scheme'] ) && ( false === $url_spec['allow_empty'] ) ) {
				$url = '';
			}

			// If the URL is empty and ampty is disallowed, remove entire declaration.
			// Otherwise, rebuild the declaration.
			if ( empty( $url ) && ( false === $url_spec['allow_empty'] ) ) {
				$styles = '';
			} else {
				$styles = $before_url . 'url(' . $url . ')' . $after_url;
			}
		}

		return $styles;
	}

	/**
	 * Sanitize the cdata in a CSS declaration based on the cdata_spec_list.
	 *
	 * The $cdata_spec_list should come from the $allowed_styles array in the 
	 * AMP_Allowed_Styles_Generated class nthat is generated by the 
	 * amp_wp_build_styles.py python script.
	 *
	 * Currently, the only part of this specification that could apply to 
	 * custom AMP styles generated from inline styles is 'blacklisted_cdata_regex'.
	 * If other sections are added to the cdata_spec_list, they should be added
	 * here.
	 *
	 * Following is an example `cdata_spec_list`:
	 *
	 * 'cdata_spec_list' => array(
	 * 		'blacklisted_cdata_regex' => array(
	 * 			'<!--',
	 * 			'\\.i?-amp-',
	 * 			'(^|\\W)i-amphtml-',
	 * 			'!important',
	 * 		),
	 * 		...
	 * ),
	 *
	 * @param  string $styles           CSS declaration to sanitize.
	 * @param  array   $cdata_spec_list cdata_spec_list to use when processing.
	 * @return string                   Sanitized CSS declaration (may be empty).
	 */
	private function sanitize_cdata( $styles, $cdata_spec_list ) {
		// If the cdata_spec_list contains a blacklisted_cdata_regex array, remove
		// remove any blacklisted values from the $styles declaration.
		if ( isset( $cdata_spec_list['blacklisted_cdata_regex'] ) &&
			is_array( $cdata_spec_list['blacklisted_cdata_regex'] ) ) {
			$regex_pattern = '%' . implode( '|', $cdata_spec_list['blacklisted_cdata_regex'] ) . '%u';
			$matched = preg_match( $regex_pattern, $styles );
			if ( 1 === $matched ) {
				return '';
			}
		}

		return $styles;
	}


	/**
	 * Generate a class name based on the hash of the input data.
	 * 
	 * @param  mixed  $data The data to generate the hash from.
	 * @return string       A unique class name for the input data.
	 */
	private function generate_class_name( $data ) {
		$string = maybe_serialize( $data );
		return 'amp-wp-inline-' . md5( $string );
	}
}
